# Parallel Prime Number Sieve

##### 素数筛法的原理：

> 把从1开始的、某一范围内的正整数从小到大顺序排列， 1不是素数，首先把它筛掉。剩下的数中选择最小的数是素数，然后去掉它的倍数。依次类推，直到筛子为空时结束。
>
> 输入是1-n的数时，其实我们只需遍历到根号n即可。因为后面的数如果有合数的话，并且在我们遍历1-根号n的过程都没有被筛掉，那么它的最小因子肯定大于根号n，两个大于根号n的因子乘积一定大于n，所以后面的数没有合数。

##### 代码实现原理

使用多个进程（通过进程池创建）来处理素数，保证第一个进程处理的数组大小大于根号n(从2开始)，其余部分平分给多个进程分别处理。第一个进程(父进程)从2开始遍历，每次将素数的倍数标记，同时将该素数通过匿名管道(使用匿名管道系统开销会小一点)传给其他进程。其他进程接受到该数据后对自己处理的部分数组中是该数据的倍数的都给上标记。一直到父进程管理的数组部分遍历完毕，其余进程所管理数组部分也都区分好了是否为素数。

[ParallelPNS1.0](https://github.com/zhougb3/ParallelPNS/tree/master/ParallelPNS1.0)是让所有进程把自己管理的数组部分是素数的写到各自文件中，最后父进程再读取文件汇总成一份总的素数表。文件读写效率低下。

[ParallelPNS2.0](https://github.com/zhougb3/ParallelPNS/tree/master/ParallelPNS2.0)改进了代码，结构更加清晰，同时是让所有子进程将自己管理的数组部分是素数的通过管道传回给父进程，由父进程统一汇总写回素数表中。（父子进程之间通过两个管道实现互相通信）



##### 实现问题

```
	for (int i = 0; i < process_number; ++i) {
		if(pipe(sub_process[i].getFds_sub_read()) < 0 || pipe(sub_process[i].getFds_sub_write()) < 0) {
			std::cerr << "pipe error";  
		}
		pid_t sub = fork();
    	if( sub < 0 ){  
			std::cerr << "fork error";  
    	}  
		else if (sub > 0) {
			sub_process[i].setId(sub);
			close(sub_process[i].getFds_sub_read()[0]);
			close(sub_process[i].getFds_sub_write()[1]);			
		}
		else {
			close(sub_process[i].getFds_sub_read()[1]);
			close(sub_process[i].getFds_sub_write()[0]);
			index = i;
			break;		
		}
	}
```

这里是通过for循环创建子进程，要注意fork（）函数是父子进程都会执行的语句（父进程返回子进程ID，子进程返回0），所以后续语句要判断是不是子进程，如果是子进程就要退出for循环，否则子进程会再创建孙进程。fork的调用子进程会将父进程有的资源（fork之前声明的变量等）都拷贝一份。

##### 管道通信问题

如果所有指向管道写端的文件秒描述符都关闭了（管道写端的计数为0），而任然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。

如果有指向管道写端的文件描述符没关闭(管道写端的引用计数大于0),⽽持有管道写端的 进程也没有向管道中写数据,这时有进程从管道读端读数据,那么管道中剩余的数据都被读取后,再次read会阻塞,直到管道中有数据可读了才读取数据并返回。

如果所有指向管道读端的文件描述符都关闭了(管道读端的引用计数等于0),这时有进程向管道的写端write,那么该进程会收到信号SIGPIPE,通常会导致进程异常终止。

如果有指向管道读端的文件描述符没关闭(管道读端的引用计数大于0),而持有管道读端的 进程也没有从管道中读数据,这时有进程向管道写端写数据,那么在管道被写满时再 次write会阻塞,直到管道中有空位置了才写入数据并返回。

关闭未使用的管道文件描述符不仅仅是为了确保进程不会耗尽其文件描述符的限制——-这对于正确使用管道是非常重要的。 (使用完之后不再需要了也要close)如果写入进程没有关闭管道的读取端，那么即使在其他进程已经关闭了管道的读取端之后写入进程仍然能够向管道写入数据，最后写入进程会将数据充满整个管道，后续的写入请求会被永远阻塞。

需要注意的是，当使用两个管道，实现父子进程双向通信时，要注意会发生死锁的情况。因为创建的管道描述符默认是阻塞的。如果两个进程都试图从空管道中读取数据或尝试向已满的管道中写入数据就可能会发生死锁。

##### 算法优化问题

寻找素数花费的时间就是遍历前根号n个数并且每次将素数的倍数去掉。这里要节省时间可以注意到如下两点：

1. 我们在寻找倍数时可以排除掉偶数的情况，因为偶数的情况在n = 2的时候我们已经全部去掉了。
2. 我们在计算一个素数m的倍数时，可以从m*m开始，然后每次增加2m（因为这个素数肯定是奇数，增加一倍那就是偶数了，偶数在2的时候已经排除啦）

这两种方法结合起来有效降低了重复标记为false的可能。（但还是不能杜绝，比如245 = 5 * 49 = 7 *35）

##### 参考网址

https://blog.csdn.net/sdutstudent/article/details/53783051

https://blog.csdn.net/stack_queue/article/details/53560887

https://zh.numberempire.com/primenumbers.php



##### 总结

增加开发经验，规划好代码结构~~
